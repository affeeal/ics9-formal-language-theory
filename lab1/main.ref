$INCLUDE "LibraryEx";

$ENUM Matrix;

/*
  t.Matrix ::= [Matrix s.RowsCount s.ColsCount t.Func*]
  s.RowsCount, s.ColsCount ::= s.NUMBER
  t.Func ::= s.Coef | ({s.Add | s.Prod} t.Func t.Func)
  s.Coef ::= s.WORD

  t.Vector ::= [Matrix s.RowsCount 1 t.Func*]

  t.Interp ::= (s.Add (s.Prod t.Matrix s.Var) t.Vector)
*/

/* Terminals. */

/*
  <SymAdd> == s.Add
*/
SymAdd {
  = arc_add;
}

/*
  <SymProd> == s.Prod
*/
SymProd {
  = arc_prod;
}

/*
  <SymVar> == s.Var
*/
SymVar {
  = x;
}

/* Auxiliary functions. */

/*
  <Take-First s.Count t.From t.To> == t.From t.To

  t.From list length is greater than or equal to s.Count.
*/
Take-First {
  0 t.From t.To = t.From t.To;

  s.Count (t.Head e.Tail) (e.Elems)
    = <Take-First
        <Dec s.Count> (e.Tail) (e.Elems t.Head)
      >;
}

/*
  <Duplicate s.Count t.Elem> == t.Elem+
*/
Duplicate {
  0 t.Elem = /* empty */;

  s.Count t.Elem
    = t.Elem <Duplicate <Dec s.Count> t.Elem>;
}

/*
  <Range s.From s.To> == s.NUMBER+
  s.From, s.To ::= s.NUMBER
*/
Range {
  s.To s.To = s.To;

  s.From s.To = s.From <Range <Inc s.From> s.To>;
}

/* Matrix operations. */

/*
  <GenMatrix s.RowsCount s.ColsCount e.Funcs>
    == t.Matrix
*/
GenMatrix {
  s.RowsCount s.ColsCount e.Funcs
    = [Matrix s.RowsCount s.ColsCount e.Funcs];
}

/*
  <GetMatrixRows t.Matrix> == e.Rows
*/
GetMatrixRows {
  [Matrix 0 s.ColsCount /* empty */] = /* empty */;

  [Matrix s.RowsCount s.ColsCount e.Funcs]
    = <Take-First s.ColsCount (e.Funcs) (/* empty */)>
    : (e.Funcs^) t.Row
    = t.Row
      <GetMatrixRows
        [Matrix <Dec s.RowsCount> s.ColsCount e.Funcs]
      >;
}

/*
  <GetMatrixCols t.Matrix> == e.Cols
*/
GetMatrixCols {
  [Matrix s.RowsCount s.ColsCount e.Funcs]
    = <UnBracket
        <MapAccum
          {
            ((e.ColFuncs) e.RestCols) t.Func
              = (e.RestCols (e.ColFuncs t.Func));
          }
          (<Duplicate s.ColsCount (/* empty */)>)
          e.Funcs
        >
      >;
}

/*
  <MultiplyMatrices t.Matrix1 t.Matrix2> == t.Matrix
*/
MultiplyMatrices {
  t.Matrix1 t.Matrix2
    = t.Matrix1 : [Matrix s.RowsCount1 s.ColsCount1 e.Funcs1]
    = t.Matrix2 : [Matrix s.RowsCount2 s.ColsCount2 e.Funcs2]
    = s.ColsCount1 s.RowsCount2 : s.Count s.Count
    = <MapAccum
        (&MultiplyMatrices-Aux <GetMatrixCols t.Matrix2>)
        <GenMatrix s.RowsCount1 s.ColsCount2>
        <GetMatrixRows t.Matrix1>
      >;
}

/*
  <MultiplyMatrices-Aux e.Cols t.Matrix t.Row>
    == t.Matrix
*/
MultiplyMatrices-Aux {
  e.Cols t.Matrix t.Row
    = <MapAccum
        {
          [Matrix s.RowsCount s.ColsCount e.Funcs] t.Col
            = [Matrix
                s.RowsCount s.ColsCount
                e.Funcs <ScalProd t.Row t.Col>
              ];
        }
        t.Matrix
        e.Cols
      >;
}

/*
  <ScalProd t.Row t.Col> == t.Func

  t.Row and t.Col are not empty and of the same size.
*/
ScalProd {
  (t.Func1) (t.Func2) = (<SymProd> t.Func1 t.Func2);

  (t.Head1 e.Tail1) (t.Head2 e.Tail2)
    = (
        <SymAdd>
        (<SymProd> t.Head1 t.Head2)
        <ScalProd (e.Tail1) (e.Tail2)>
      );
}

/*
  <AddUpMatrices t.Matrix1 t.Matrix2> == t.Matrix
*/
AddUpMatrices {
  [Matrix s.RowsCount s.ColsCount e.Funcs1]
  [Matrix s.RowsCount s.ColsCount e.Funcs2]
    = [Matrix
        s.RowsCount s.ColsCount
        <AddUpFuncs (e.Funcs1) (e.Funcs2)>
      ];
}

/*
  <AddUpFuncs (e.Funcs1) (e.Funcs2)> == e.Funcs

  e.Funcs1 and e.Funcs2 are of the same size.
*/
AddUpFuncs {
  (t.Func1 e.RestFuncs1) (t.Func2 e.RestFuncs2)
    = (<SymAdd> t.Func1 t.Func2)
      <AddUpFuncs (e.RestFuncs1) (e.RestFuncs2)>;

  (/* empty */) (/* empty */) = /* empty */;
}

/* Interpretation operations. */

/*
  <GenCoef s.FuncSym s.Ind+> == s.Coef
  s.Ind ::= s.NUMBER
*/
GenCoef {
  s.FuncSym e.Inds
    = <Implode s.FuncSym <Map &Symb e.Inds>>;
}

/*
  <GenCoefs-Matrix s.FuncSym s.RowsCount s.ColsCount>
    == e.Coefs
*/
GenCoefs-Matrix {
  s.FuncSym s.RowsCount s.ColsCount
    = <Map
        {
          s.RowNum
            = <Map
                (&GenCoef s.FuncSym s.RowNum)
                <Range 1 s.ColsCount>
              >;
        } 
        <Range 1 s.RowsCount>
      >;
}

/*
  <GenCoefs-Vector s.FuncSym s.RowsCount>
    == e.Coefs
*/
GenCoefs-Vector {
  s.FuncSym s.RowsCount
    = <Map
        (&GenCoef s.FuncSym)
        <Range 1 s.RowsCount>
      >;
}

/*
  <GenInterp s.FuncSym> == t.Interp
*/
GenInterp {
  s.FuncSym
    = (
        <SymAdd>
        (
          <SymProd>
          <GenMatrix 2 2 <GenCoefs-Matrix s.FuncSym 2 2>>
          <SymVar>
        )
        <GenMatrix 2 1 <GenCoefs-Vector s.FuncSym 2>>
      );
}

/*
  <DoInterpComposition t.Interp1 t.Interp2> == t.Interp
*/
DoInterpComposition {
  /* Assuming <SymAdd> : s.Add, <SymProd> : s.Prod
     and <SymVar> : s.SymVar. */
  (s.Add (s.Prod t.Matrix1 s.Var) t.Vector1)
  (s.Add (s.Prod t.Matrix2 s.Var) t.Vector2)
    = (
        s.Add
        (
          s.Prod
          <MultiplyMatrices t.Matrix1 t.Matrix2>
          s.Var
        )
        <AddUpMatrices
          <MultiplyMatrices t.Matrix1 t.Vector2>
          t.Vector1
        >
      );
}

/*
  <InterpretString s.FuncSym+> == t.Interp
  s.FuncSym ::= s.CHAR
*/
InterpretString {
  s.FuncSym = <GenInterp s.FuncSym>;

  s.FuncSym e.RestString
    = <DoInterpComposition
        <GenInterp s.FuncSym>
        <InterpretString e.RestString>
      >;
}

$ENTRY Go {
  /* demonstraion */
  = <Prout
      <InterpretString 'fg'>
    >;
}

